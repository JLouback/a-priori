GROUP INFORMATION
-----------------
Juliana Louback (jl4354) & Anthony Dubis (ajd2194)


FILES
-----
- Algorithmn.java - Contains the a-priori algorithm and rule generator
- Interaction.java - Handles user interaction
- Itemset.java - object for storing an item set and its respective support
- Rule.java - object for storing a rule and its respective support and confidence
- Utils.java - contains supportive method for BitSet manipulation


DATA
----

HOW TO RUN
----------
java -jar a-priori.jar <dataset file> <min_sup> <min_conf>

INTERNAL DESIGN
---------------

The implementation essentially follows the provided algorithm as specified, but
there are two details worth mentioning. First, we filter out new frequent
itemset candidates immediately after joining them (and before they are pruned).
This prevents itemsets that would eventually get discarded because they don't
have the minimum support from going through the pruning function.

Second, we create bit vectors for each individual item/term which specifies
which rows/transactions the item occurs in. This data structure gives us a way
to quickly AND together bit vectors for other terms (to determine which
transactions share an item) and then count the number of transactions that
contain a given subset of items. It also allows us to read the data set only
once as the bit vectors then contain everything we need to run the algorithm.
This enhancement dropped our exection time from 10-20 minutes to a fraction of a
second even with the largest of datasets.

A detailed explanation of the files and main methods are below.

Interaction.java
----------------
Receives the dataset file path, support and confidence thresholds from the
command line and with it initializes an Algorithm object and calls execute().


Algorithm.execute()
-------------------
1 Run firstItemset() to obtain a set of single term Itemsets (k=1) which make the
  minimum support threshold:

  When initializing an Algorithm object with a given dataset, we initialize a
  HashMap with a term as key and a bit vector as value for each term we
  encounter in the dataset. The bit vector indicates which transactions contain
  a given term. For example, assume we have four transactions. An item A has a bit
  vector of 1101 (indicating it is present in transactions 1, 2, and 4) and item
  B has a bit vector of 1011 (present in 1, 3 and 4). The AND of bit vector A and
  bit vector B gives us 1001. This implies that transactions 1 and 4 contain both
  A and B. Given that these bitwise operations are extremely fast, this improved
  the running time of our algorithm dramatically. And since the calculations for
  support and confidence essentially involves getting the total number of 
  transactions that contain a given set of items, all we have to do is count
  the number of 1s in the bit vector once we're done with our operations.
  With these bit vectors, firstItemset() counts the 1’s in each term’s bit vector 
  and generates an Itemset object with the calculated support for the term; only 
  Itemsets with sufficient support are returned in a set.

2 Run aprioriGen() increments k until the set of Itemsets with k items is empty,
  storing the set of Itemsets at each iteration in a list L. On each iteration,
  the following steps are performed:

  2.1 join() is used to create all k-sized sets from the (k-1)-sized sets passed
      into it (from the previous iteration of the algorithm). The sets are only
      created if they are valid according to section 2.1.1 of the paper. They
      are also discard if they do not meet the min_sup threshold.
  2.2 prune() receives two sets of Itemsets, that of round k-1 and round k.
      It verifies that all the possible subsets of Itemsets obtained in round
      k are present in the set of Itemsets of round k-1, removing those which
      don’t pass the verification from the return set.
  2.3 Return the set of Itemsets that ‘survived’ step 2.2.

3 Run writeFrequentItemsets() to write to output.txt the Itemsets that have
  sufficient support, contained in list L returned by step 2.

4 Run getRules() to generate a list of Rule objects for the Itemsets in L, 
  filtering Rules that don’t meet confidence requirements:
  For each Itemset x in the list L of candidate item sets, for each possible n
  choose 1 combination, create a Rule with 1 item of x on the RHS and all the other
  items of x on the LHS:

  4.1 Calculate the confidence of the Rule: (the cardinality of an AND of all bit
      vectors for items in the LHS and RHS) divided by (the cardinality of an AND
      of all bit vectors for items in the LHS). If the confidence is sufficient,
      save the Rule (with its respective support and confidence) to the return list.

5 Run writeRules() to write to output.txt the association rules found in the data that
  adhere to the specified confidence and support requirements, returned on step 4.
	

SAMPLE RUN
----------
java -jar a-priori.jar <dataset file> <min_sup> <min_conf>
